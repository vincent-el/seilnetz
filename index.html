<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seilnetz V2.2: The Sonic Web</title>

    <!-- CDN Dependencies -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/gsap@3.12.2/dist/gsap.min.js"></script>

    <style>
        :root {
            --bg: #f5f5f5;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --text: #222;
            --text-muted: #666;
            --accent: #d4a017;
            /* Yellow */
            --glow: #cc2936;
            /* Red */
            --success: #2ecc71;
            --border: #ddd;
            --debug-bg: #1a1a1a;
            --debug-text: #0f0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'SF Mono', 'Menlo', monospace;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* === 3D CANVAS === */
        #canvas-container {
            position: fixed;
            inset: 0;
            z-index: 0;
        }

        /* === UI SIDEBAR === */
        #ui-layer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10;
            display: flex;
            justify-content: flex-end;
        }

        #panel {
            width: 340px;
            height: 100%;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            border-left: 1px solid var(--border);
            padding: 20px;
            pointer-events: auto;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.05);
        }

        h1 {
            font-size: 1rem;
            color: var(--glow);
            margin: 0 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--glow);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        section {
            margin-bottom: 24px;
        }

        h2 {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0 0 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Status LEDs */
        .status-row {
            display: flex;
            align-items: center;
            font-size: 0.8rem;
            margin-bottom: 6px;
        }

        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
            margin-right: 10px;
            transition: all 0.3s;
        }

        .led.on {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        /* Controls */
        button {
            width: 100%;
            padding: 10px;
            background: var(--text);
            color: white;
            border: none;
            font-family: inherit;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
        }

        button:hover {
            background: #444;
        }

        button.active {
            background: var(--accent);
            color: #000;
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
        }

        button.secondary:hover {
            background: #eee;
        }

        select {
            width: 100%;
            padding: 8px;
            font-family: inherit;
            font-size: 0.8rem;
            border: 1px solid var(--border);
            background: white;
            margin-bottom: 12px;
        }

        /* === SOUNDSCAPE VISUALIZER === */
        #adsr-canvas {
            width: 100%;
            height: 100px;
            background: #fff;
            border: 1px solid var(--border);
            margin-bottom: 8px;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .param-value {
            color: var(--text);
            font-weight: bold;
            float: right;
        }

        /* === LOG === */
        #log {
            flex: 1;
            min-height: 100px;
            background: #fff;
            border: 1px solid var(--border);
            padding: 10px;
            font-size: 0.65rem;
            overflow-y: auto;
            color: var(--text-muted);
        }

        .log-entry {
            margin-bottom: 2px;
            border-bottom: 1px solid #eee;
            padding-bottom: 2px;
        }

        .log-time {
            opacity: 0.5;
            margin-right: 5px;
        }

        /* === LABELS === */
        .node-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-family: var(--mono);
            pointer-events: none;
            border: 1px solid var(--accent);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: translate(-50%, -100%);
            margin-top: -15px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .node-label.visible {
            opacity: 1;
        }

        .node-label strong {
            color: var(--glow);
        }

        /* === DEBUG FOOTER === */
        #debug-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: calc(100% - 340px);
            /* Subtract panel width */
            background: var(--debug-bg);
            color: #eee;
            border-top: 2px solid var(--accent);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 20;
            display: flex;
            flex-direction: column;
            height: 300px;
        }

        #debug-footer.open {
            transform: translateY(0);
        }

        .debug-header {
            padding: 8px 16px;
            background: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
        }

        .debug-content {
            display: grid;
            grid-template-columns: 250px 1fr;
            height: 100%;
            overflow: hidden;
        }

        .debug-sidebar {
            padding: 16px;
            border-right: 1px solid #444;
            background: #222;
            font-size: 0.8rem;
        }

        .debug-log {
            padding: 16px;
            font-family: 'Monaco', monospace;
            font-size: 0.75rem;
            color: var(--debug-text);
            overflow-y: auto;
            background: #111;
        }

        .debug-stat {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .debug-toggle {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 30;
            background: var(--debug-bg);
            color: #fff;
            border: 1px solid var(--border);
            padding: 5px 10px;
            font-size: 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            width: auto;
        }

        /* === OVERLAY === */
        #overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            cursor: pointer;
            transition: opacity 0.5s;
        }

        #overlay h1 {
            color: white;
            border: none;
            font-size: 2rem;
        }
    </style>
</head>

<body>

    <div id="overlay">
        <h1>üï∏Ô∏è SEILNETZ</h1>
        <p>Click anywhere to enter</p>
    </div>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <button id="debug-toggle" class="debug-toggle">üõ†Ô∏è Debug Console</button>

    <div id="debug-footer">
        <div class="debug-header">
            <span>Hardware Diagnostics</span>
            <button onclick="app.debug.clear()" style="width: auto; padding: 4px 8px; margin: 0;">Clear Log</button>
        </div>
        <div class="debug-content">
            <div class="debug-sidebar">
                <div class="debug-stat"><span>API Status:</span> <span id="dbg-api">Checking...</span></div>
                <div class="debug-stat"><span>Inputs:</span> <span id="dbg-inputs">0</span></div>
                <div class="debug-stat"><span>Last Msg:</span> <span id="dbg-last">-</span></div>
                <div class="debug-stat" style="margin-top: 20px; color: #888;">
                    MIDI Channel ‚Üí Sensor Mapping:<br>
                    Ch 1 ‚Üí Sensor 0<br>
                    Ch 2 ‚Üí Sensor 1<br>
                    ...<br>
                    Ch 6 ‚Üí Sensor 5
                </div>
            </div>
            <div id="raw-midi-log" class="debug-log">Waiting for MIDI...</div>
        </div>
    </div>

    <div id="ui-layer">
        <div id="panel">
            <h1>üï∏Ô∏è Seilnetz</h1>

            <section>
                <h2>Status</h2>
                <div class="status-row">
                    <div id="led-audio" class="led"></div>
                    <span>Audio Engine</span>
                </div>
                <div class="status-row">
                    <div id="led-midi" class="led"></div>
                    <span id="midi-name">No MIDI Device</span>
                </div>
            </section>

            <section>
                <h2>Visualization</h2>
                <button id="btn-labels" class="secondary active">Show Labels</button>
            </section>

            <section>
                <h2>Soundscape</h2>
                <select id="preset-select">
                    <option value="safe">CMaj9 ‚Äì Safe & Warm</option>
                    <option value="bright">Pentatonic ‚Äì Bright</option>
                    <option value="eno">Eno Drones ‚Äì Ambient</option>
                    <option value="abm7">A‚ô≠m7 ‚Äì Melancholic</option>
                    <option value="cbmaj7">C‚ô≠maj7 ‚Äì Ethereal</option>
                    <option value="chaos">Chaos ‚Äì 5 + Screech</option>
                </select>

                <canvas id="adsr-canvas" width="300" height="100"></canvas>
                <div class="param-grid" id="sound-params">
                    <!-- Filled by JS -->
                </div>
            </section>

            <section>
                <h2>Simulation</h2>
                <button id="btn-auto">Start Auto-Play</button>
            </section>

            <section style="flex: 1; display: flex; flex-direction: column;">
                <h2>
                    Event Log
                    <span style="font-size: 0.6rem; cursor: pointer;" onclick="app.clearLog()">CLEAR</span>
                </h2>
                <div id="log"></div>
            </section>
        </div>
    </div>

    <script>
        /**
         * SEILNETZ V2.2
         * Integrated Soundscape Visualizer & Debug Console
         */

        // === CONFIGURATION ===
        const PRESETS = {
            safe: {
                name: 'CMaj9 Safe',
                notes: [36, 43, 52, 59, 62, 67],
                envelope: { attack: 0.3, decay: 0.2, sustain: 0.6, release: 4 },
                oscillator: 'sine',
                filterFreq: 3000,
                reverbWet: 0.5
            },
            bright: {
                name: 'Pentatonic Bright',
                notes: [60, 62, 64, 67, 69, 72],
                envelope: { attack: 0.1, decay: 0.1, sustain: 0.8, release: 2 },
                oscillator: 'triangle',
                filterFreq: 8000,
                reverbWet: 0.3
            },
            eno: {
                name: 'Eno Drones',
                notes: [36, 52, 55, 59, 64, 71],
                envelope: { attack: 2, decay: 0.5, sustain: 0.8, release: 12 },
                oscillator: 'sine',
                filterFreq: 3000,
                reverbWet: 0.9
            },
            abm7: {
                name: 'A‚ô≠m7 ‚Äì Melancholic',
                notes: [44, 48, 51, 54, 56, 60],
                envelope: { attack: 0.1, decay: 0.1, sustain: 0.8, release: 2 },
                oscillator: 'triangle',
                filterFreq: 8000,
                reverbWet: 0.3
            },
            cbmaj7: {
                name: 'C‚ô≠maj7 ‚Äì Ethereal',
                notes: [35, 39, 42, 47, 51, 58],
                envelope: { attack: 0.1, decay: 0.1, sustain: 0.8, release: 2 },
                oscillator: 'triangle',
                filterFreq: 8000,
                reverbWet: 0.3
            },
            chaos: {
                name: 'Chaos + Screech',
                notes: [48, 52, 55, 59, 62, 96],
                envelope: { attack: 0.01, decay: 0.1, sustain: 1, release: 0.5 },
                oscillator: 'square',
                filterFreq: 10000,
                reverbWet: 0.2
            }
        };

        // Flat "Web" Topology
        const RADIUS = 3.5;
        const NODE_POSITIONS = [{ x: 0, y: 0, z: 0 }]; // Center
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            NODE_POSITIONS.push({
                x: Math.cos(angle) * RADIUS,
                y: 0,
                z: Math.sin(angle) * RADIUS
            });
        }

        // === EVENT BUS ===
        class Bus {
            constructor() { this.subs = {}; }
            on(e, fn) { (this.subs[e] ||= []).push(fn); }
            emit(e, d) { this.subs[e]?.forEach(fn => fn(d)); }
        }

        // === SOUNDSCAPE VISUALIZER ===
        class SoundscapeViz {
            constructor(canvasId, paramsId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.paramsEl = document.getElementById(paramsId);
            }

            draw(preset) {
                const { width, height } = this.canvas;
                const ctx = this.ctx;
                const env = preset.envelope;

                // Clear
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(0, 0, width, height);

                // Calc points
                const totalTime = env.attack + env.decay + 1 + env.release; // 1s sustain for viz
                const timeScale = width / Math.min(totalTime, 5); // Cap visual width

                const attackX = env.attack * timeScale;
                const decayX = attackX + (env.decay * timeScale);
                const sustainX = decayX + (1 * timeScale);
                const releaseX = sustainX + (env.release * timeScale);

                const sustainY = height - (env.sustain * height * 0.8);
                const peakY = height * 0.1;
                const baseY = height;

                // Draw Curve
                ctx.beginPath();
                ctx.moveTo(0, baseY);
                ctx.lineTo(attackX, peakY); // Attack
                ctx.lineTo(decayX, sustainY); // Decay
                ctx.lineTo(sustainX, sustainY); // Sustain
                ctx.lineTo(releaseX, baseY); // Release

                ctx.strokeStyle = '#d4a017';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'rgba(212, 160, 23, 0.1)';
                ctx.fill();

                // Waveform Icon
                this.drawWaveform(preset.oscillator, width - 30, 20);

                // Update Params Text
                this.paramsEl.innerHTML = `
            <div>Attack <span class="param-value">${env.attack}s</span></div>
            <div>Release <span class="param-value">${env.release}s</span></div>
            <div>Wave <span class="param-value">${preset.oscillator}</span></div>
            <div>Reverb <span class="param-value">${preset.reverbWet * 100}%</span></div>
        `;
            }

            drawWaveform(type, x, y) {
                const ctx = this.ctx;
                ctx.beginPath();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1.5;

                if (type === 'sine') {
                    ctx.moveTo(x, y);
                    ctx.bezierCurveTo(x + 5, y - 10, x + 10, y + 10, x + 15, y);
                } else if (type === 'square') {
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y - 8);
                    ctx.lineTo(x + 7, y - 8);
                    ctx.lineTo(x + 7, y + 8);
                    ctx.lineTo(x + 15, y + 8);
                    ctx.lineTo(x + 15, y);
                } else if (type === 'triangle') {
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 7, y - 10);
                    ctx.lineTo(x + 15, y);
                }
                ctx.stroke();
            }
        }

        // === DEBUGGER ===
        class Debugger {
            constructor() {
                this.el = {
                    footer: document.getElementById('debug-footer'),
                    toggle: document.getElementById('debug-toggle'),
                    log: document.getElementById('raw-midi-log'),
                    api: document.getElementById('dbg-api'),
                    inputs: document.getElementById('dbg-inputs'),
                    last: document.getElementById('dbg-last')
                };

                this.isOpen = false;
                this.el.toggle.onclick = () => this.toggle();

                // Check API immediately
                if (navigator.requestMIDIAccess) {
                    this.el.api.textContent = "Available";
                    this.el.api.style.color = "#0f0";
                } else {
                    this.el.api.textContent = "Not Supported";
                    this.el.api.style.color = "#f00";
                }
            }

            toggle() {
                this.isOpen = !this.isOpen;
                this.el.footer.classList.toggle('open', this.isOpen);
                this.el.toggle.classList.toggle('active', this.isOpen);
            }

            log(msg) {
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                this.el.log.prepend(line);
                if (this.el.log.children.length > 50) this.el.log.lastChild.remove();
                this.el.last.textContent = msg;
            }

            updateInputs(count) {
                this.el.inputs.textContent = count;
            }

            clear() {
                this.el.log.innerHTML = '';
            }
        }

        // === AUDIO ENGINE ===
        class Audio {
            constructor(bus, viz) {
                this.bus = bus;
                this.viz = viz;
                this.synth = null;
                this.filter = null;
                this.reverb = null;
                this.preset = PRESETS.safe;
                this.ready = false;

                bus.on('trigger', d => this.play(d.sensor, d.velocity));
                bus.on('preset', name => this.setPreset(name));

                // Initial Draw
                this.viz.draw(this.preset);
            }

            async init() {
                await Tone.start();
                this.synth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 8 });
                this.filter = new Tone.Filter(3000, 'lowpass');
                this.reverb = new Tone.Reverb({ decay: 8, wet: 0.5 });
                this.synth.chain(this.filter, this.reverb, Tone.Destination);
                this.applyPreset();
                this.ready = true;
            }

            setPreset(name) {
                this.preset = PRESETS[name] || PRESETS.safe;
                this.viz.draw(this.preset); // Update visualizer
                if (this.ready) this.applyPreset();
            }

            applyPreset() {
                const p = this.preset;
                this.synth.set({
                    oscillator: { type: p.oscillator },
                    envelope: p.envelope
                });
                this.filter.frequency.value = p.filterFreq;
                this.reverb.wet.value = p.reverbWet;
            }

            play(sensor, velocity) {
                if (!this.ready) return;
                const note = this.preset.notes[sensor % this.preset.notes.length];
                const noteName = Tone.Frequency(note, 'midi').toNote();
                const vol = velocity / 127;
                this.synth.triggerAttack(noteName, Tone.now(), vol);
                const holdTime = this.preset.envelope.attack + 0.1;
                this.synth.triggerRelease(noteName, Tone.now() + holdTime);
            }
        }

        // === 3D VISUALIZER ===
        class Viz {
            constructor(container, bus) {
                this.bus = bus;
                this.nodes = [];
                this.basePosY = [];
                this.labels = [];
                this.showLabels = true;
                this.container = container;
                this.labelsContainer = document.getElementById('labels-container');

                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf5f5f5);

                // Camera
                this.camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
                this.camera.position.set(0, 6, 6);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.setPixelRatio(devicePixelRatio);
                container.appendChild(this.renderer.domElement);

                // Controls
                const canvas = this.renderer.domElement;
                let isDragging = false, prevMouse = { x: 0, y: 0 };
                let rot = { x: 0.5, y: 0 };

                canvas.addEventListener('mousedown', e => { isDragging = true; prevMouse = { x: e.clientX, y: e.clientY } });
                canvas.addEventListener('mousemove', e => {
                    if (!isDragging) return;
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    rot.y += dx * 0.005;
                    rot.x += dy * 0.005;
                    rot.x = Math.max(0.1, Math.min(1.5, rot.x)); // Limit vertical

                    // Orbit logic
                    const dist = 8;
                    this.camera.position.x = Math.sin(rot.y) * dist;
                    this.camera.position.z = Math.cos(rot.y) * dist;
                    this.camera.position.y = rot.x * 5;
                    this.camera.lookAt(0, 0, 0);

                    prevMouse = { x: e.clientX, y: e.clientY };
                });
                canvas.addEventListener('mouseup', () => isDragging = false);

                // Lights
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const sun = new THREE.DirectionalLight(0xffffff, 0.8);
                sun.position.set(5, 10, 5);
                this.scene.add(sun);

                this.createNet();
                this.animate();

                bus.on('trigger', d => this.triggerNode(d.sensor, d.velocity));
                bus.on('toggle-labels', show => this.toggleLabels(show));
                window.addEventListener('resize', () => this.resize());
            }

            createNet() {
                this.netGroup = new THREE.Group();
                this.netGroup.position.x = -1.5; // Offset for UI
                this.scene.add(this.netGroup);

                const geo = new THREE.SphereGeometry(0.4, 32, 32);

                NODE_POSITIONS.forEach((pos, i) => {
                    // Mesh
                    const mat = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: 0xcc2936,
                        emissiveIntensity: 0.1,
                        roughness: 0.3, metalness: 0.1
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(pos.x, pos.y, pos.z);
                    this.netGroup.add(mesh);
                    this.nodes.push(mesh);
                    this.basePosY.push(pos.y);

                    // Label
                    const label = document.createElement('div');
                    label.className = 'node-label visible';
                    label.innerHTML = `<strong>Sensor ${i}</strong><br>Ch ${i + 1}`;
                    this.labelsContainer.appendChild(label);
                    this.labels.push({ el: label, obj: mesh });
                });

                // Edges
                const lineMat = new THREE.LineBasicMaterial({ color: 0xcccccc, linewidth: 2 });
                for (let i = 1; i < this.nodes.length; i++) {
                    // Center to ring
                    let pts = [this.nodes[0].position.clone(), this.nodes[i].position.clone()];
                    let lineGeo = new THREE.BufferGeometry().setFromPoints(pts);
                    this.netGroup.add(new THREE.Line(lineGeo, lineMat));

                    // Ring to ring
                    let next = i === this.nodes.length - 1 ? 1 : i + 1;
                    pts = [this.nodes[i].position.clone(), this.nodes[next].position.clone()];
                    lineGeo = new THREE.BufferGeometry().setFromPoints(pts);
                    this.netGroup.add(new THREE.Line(lineGeo, lineMat));
                }
            }

            toggleLabels(show) {
                this.showLabels = show;
                this.labels.forEach(l => {
                    l.el.classList.toggle('visible', show);
                });
            }

            triggerNode(index, velocity) {
                const node = this.nodes[index];
                if (!node) return;
                const intensity = velocity / 127;

                gsap.fromTo(node.scale, { x: 1.8, y: 1.8, z: 1.8 }, { x: 1, y: 1, z: 1, duration: 0.5, ease: 'elastic.out(1,0.4)' });
                gsap.fromTo(node.material, { emissiveIntensity: 1.5 * intensity }, { emissiveIntensity: 0.1, duration: 2 });
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Update Labels
                if (this.showLabels) {
                    this.labels.forEach(item => {
                        // Project 3D to 2D
                        const vector = item.obj.position.clone();
                        vector.applyMatrix4(this.netGroup.matrixWorld); // Apply offset
                        vector.project(this.camera);

                        const x = (vector.x * .5 + .5) * innerWidth;
                        const y = (-(vector.y * .5) + .5) * innerHeight;

                        // Only show if in front of camera
                        if (vector.z < 1) {
                            item.el.style.transform = `translate(-50%, -100%) translate(${x}px,${y}px)`;
                            item.el.style.display = 'block';
                        } else {
                            item.el.style.display = 'none';
                        }
                    });
                }

                this.renderer.render(this.scene, this.camera);
            }

            resize() {
                this.camera.aspect = innerWidth / innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(innerWidth, innerHeight);
            }
        }

        // === MIDI CONFIGURATION ===
        // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        // ‚îÇ  Adjust these for your hardware setup                  ‚îÇ
        // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        const MIDI_CONFIG = {
            // Which channels to accept (1-indexed, matches hardware)
            // Example: [1, 2, 3] = only 3 sensors connected
            // Example: [1, 2, 3, 4, 5, 6] = all 6 sensors
            enabledChannels: [1, 2, 3],

            // Minimum velocity to trigger (0-127)
            // Higher = less sensitive, filters weak hits & crosstalk
            // 0 = any touch, 30 = light hits, 60 = firm hits only
            velocityThreshold: 30,

            // Milliseconds to ignore repeat triggers per sensor
            // Prevents "ringing" from piezo vibration
            // 150 = responsive, 300 = stable, 500 = very stable
            debounceMs: 200
        };

        // === MIDI INPUT ===
        class MIDI {
            constructor(bus, debug) {
                this.bus = bus;
                this.debug = debug;
                this.init();
            }

            async init() {
                try {
                    const access = await navigator.requestMIDIAccess();
                    this.bind(access);
                    access.onstatechange = () => this.bind(access);
                } catch (e) {
                    this.bus.emit('log', 'MIDI: Not available');
                }
            }

            bind(access) {
                let found = false;
                let count = 0;
                const lastTrigger = [0, 0, 0, 0, 0, 0];

                access.inputs.forEach(input => {
                    found = true;
                    count++;
                    this.bus.emit('midi-status', { connected: true, name: input.name });

                    input.onmidimessage = msg => {
                        const [status, note, vel] = msg.data;
                        const ch = (status & 0x0F) + 1;
                        const type = status & 0xF0;

                        // DEBUG LOGGING (always log raw for diagnostics)
                        this.debug.log(`RAW: [${status}] Ch:${ch} Note:${note} Vel:${vel}`);

                        // FILTER: Note On messages only
                        if (type !== 0x90) return;

                        // FILTER: Channel must be in enabled list
                        if (!MIDI_CONFIG.enabledChannels.includes(ch)) return;

                        // FILTER: Velocity must exceed threshold
                        if (vel < MIDI_CONFIG.velocityThreshold) return;

                        const sensor = ch - 1; // Mapping Ch1->Sensor0
                        const now = Date.now();

                        // FILTER: Debounce rapid triggers
                        if (now - lastTrigger[sensor] < MIDI_CONFIG.debounceMs) return;

                        lastTrigger[sensor] = now;
                        this.bus.emit('trigger', { sensor, velocity: vel, source: 'MIDI', channel: ch });
                    };
                });
                this.debug.updateInputs(count);
                if (!found) this.bus.emit('midi-status', { connected: false });
            }
        }

        // === MAIN APP ===
        class App {
            constructor() {
                this.bus = new Bus();
                this.debug = new Debugger();
                this.soundViz = new SoundscapeViz('adsr-canvas', 'sound-params');

                // UI Refs
                this.$ = {
                    overlay: document.getElementById('overlay'),
                    ledAudio: document.getElementById('led-audio'),
                    ledMidi: document.getElementById('led-midi'),
                    midiName: document.getElementById('midi-name'),
                    btnAuto: document.getElementById('btn-auto'),
                    btnLabels: document.getElementById('btn-labels'),
                    presetSelect: document.getElementById('preset-select'),
                    log: document.getElementById('log')
                };

                // Modules
                this.viz = new Viz(document.getElementById('canvas-container'), this.bus);
                this.audio = new Audio(this.bus, this.soundViz);
                this.midi = new MIDI(this.bus, this.debug);

                // Other inputs
                this.auto = new AutoPlay(this.bus);
                this.setupKeyboard();

                this.bindUI();
                this.bindLog();
            }

            setupKeyboard() {
                document.addEventListener('keydown', e => {
                    if (e.repeat) return;
                    const n = parseInt(e.key);
                    if (n >= 1 && n <= 6) {
                        this.bus.emit('trigger', { sensor: n - 1, velocity: 80, source: 'KBD' });
                    }
                });
            }

            bindUI() {
                // Start Audio
                this.$.overlay.onclick = async () => {
                    await this.audio.init();
                    this.$.overlay.style.opacity = 0;
                    setTimeout(() => this.$.overlay.remove(), 500);
                    this.$.ledAudio.classList.add('on');
                    this.log('Audio started');
                };

                // Auto-play
                this.$.btnAuto.onclick = () => {
                    const on = this.auto.toggle();
                    this.$.btnAuto.textContent = on ? 'Stop Auto-Play' : 'Start Auto-Play';
                    this.$.btnAuto.classList.toggle('active', on);
                };

                // Toggle Labels
                this.$.btnLabels.onclick = () => {
                    const isActive = this.$.btnLabels.classList.toggle('active');
                    this.$.btnLabels.textContent = isActive ? 'Hide Labels' : 'Show Labels';
                    this.bus.emit('toggle-labels', isActive);
                };

                // Presets
                this.$.presetSelect.onchange = e => {
                    this.bus.emit('preset', e.target.value);
                    this.log(`Preset: ${PRESETS[e.target.value].name}`);
                };

                // MIDI Status
                this.bus.on('midi-status', s => {
                    this.$.ledMidi.classList.toggle('on', s.connected);
                    this.$.midiName.textContent = s.connected ? s.name : 'No MIDI Device';
                    if (s.connected) this.log(`MIDI: ${s.name}`);
                });
            }

            bindLog() {
                this.bus.on('trigger', d => this.log(`[${d.source}] Sensor ${d.sensor} (Ch${d.channel || '-'}) @ ${d.velocity}`));
                this.bus.on('log', msg => this.log(msg));
            }

            log(msg) {
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.innerHTML = `<span class="log-time">${new Date().toISOString().slice(14, 23)}</span> ${msg}`;
                this.$.log.prepend(div);
                while (this.$.log.children.length > 20) this.$.log.lastChild.remove();
            }

            clearLog() {
                this.$.log.innerHTML = '';
            }
        }

        // Helper for AutoPlay (simplified for brevity)
        class AutoPlay {
            constructor(bus) { this.bus = bus; this.running = false; }
            toggle() { this.running = !this.running; if (this.running) this.tick(); return this.running; }
            tick() {
                if (!this.running) return;
                this.bus.emit('trigger', { sensor: Math.floor(Math.random() * 6), velocity: 60 + Math.floor(Math.random() * 60), source: 'AUTO' });
                setTimeout(() => this.tick(), 200 + Math.random() * 600);
            }
        }

        window.addEventListener('DOMContentLoaded', () => window.app = new App());
    </script>
</body>

</html>